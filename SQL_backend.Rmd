---
title: "Adding a new SQL backend"
date: "2015-06-15"
output: html_document
---

### Перевод
### https://cran.r-project.org/web/packages/dplyr/vignettes/new-sql-backend.html

```{r, echo=FALSE, warning=FALSE, message=FALSE}
setwd("D:/GITHUB/dplyr_doc_ru")
library(dplyr)
```

Этот документ описывает, как создать новый SQL бекенд (серверную часть) для dpyr (работа над этим в процессе). Если вы знакомы с тем, как работает ваша база данных, и по меньшей мере с одной другой базой данных, которая уже поддерживается dplyr, это должно быть достаточно просто, и я буду рад помочь, если вы застряли. Также возможно, что новый бекенд базы данных потребует новых методов - я также буду рад их добавить, если нужно. Если вам требуется больше помощи, воспользуйтесь [рассылкой](manipulatr@googlegroups.com), и я помогу вам разобраться.

dplyr используется S3-объекты, так что прежде убедитесь, что вы знакомы с [основами](http://adv-r.had.co.nz/OO-essentials.html#s3).

См. `?backend_sql` и`?backend_db` для полного списка общих функций.

## Создание объекта src

Начинаем с создания новой функции src для представления бекенда. Предположим, мы собираемся создать src для mssql, тогда назовем её `src_mssql()` и будем следовать
структуре существующией src. Упрощенная версия `src_postgres()` представлена ниже:

```{r}
src_postgres <- function(dbname = NULL, host = NULL, 
                         port = NULL, user = NULL,
                         password = NULL, ...) {

  con <- dbConnect(PostgreSQL(), host = host %||% "", 
                   dbname = dbname %||% "", user = user, 
                   password = password %||% "", 
                   port = port %||% "", ...)

  src_sql("postgres", con)
}
```

Используйте `src_sql()` для создания S3-объекта с правильной структурой. Это должно быть соединение DBI, но вы можете сохранить ещё что угодно, что может быть полезным.

Затем реализуйте метод для `src_desc()`, который кратко описывает источник:

```{r}
rc_desc.src_postgres <- function(x) {
  info <- dbGetInfo(con)
  host <- if (info$host == "") "localhost" else info$host

  paste0("postgres ", info$serverVersion, " [", info$user, "@",
    host, ":", info$port, "/", info$dbname, "]")
}
```

Если вы прочитаете исходный код настоящей функции `src_postgres()`, то заметите, что  при создании она кэширует поле `getGetInfo()`, так как это экономит немного времени при печати таблиц.

Прежде чем продолжить, убедитесь, что вы можете создать подключение к локальной базе данных. Не волнуйтесь, если объект не печатается правильно, вы должны будете сперва добавить несколько других методов.

## Список таблиц

Далее реализуйте два метода, которые позволяют dplyr запрашивать таблицы, присутствующие в базе данных:

* `db_list_tables()`

* `db_has_table()`

Это должно быть очень просто, если существует готовый интерфейс DBI, и немного сложнее, если его нет. Эти методы в основном обеспечивают обёртку вокруг отдельных пакетов для баз данных, чтобы опеспечить их одинаковое поведение. Подробности см. в документации.

После того, как вы реализовали эти методы, вы должны быть в состоянии подключиться к локальной базе данных и получить полезное описание, в том числе список таблиц. Не продолжайте, пока это не будет работать.

### tbl

Далее реализуйте метод `tbl()` для вашего источника данных. Это, вероятно, будет просто

```{r}
tbl.src_mssql <- function(src, from, ...) {
  tbl_sql("mssql", src = src, from = from, ...)
}
```

Прежде чем продолжить, убедитесь, что вы можете подключиться к существующей таблице, и что результаты выводятся корректно. Если это не так, возможно, ваша база данных использует нестандартный интерфейс DBI. Это означает, что вам, возможно, нужен подкласс класса запросов [R6](https://cran.r-project.org/web/packages/R6/vignettes/Introduction.html) и новый метод запроса `S3`, который создает новый объект запроса. Если это ваш случай, то настоятельно рекомендую обратиться за помощью.

Сейчас также удачный момент для реализации `explain()` при помощи добавления метода для `db_explain()`.

Если ваша база данных использует нестандартное цитирование (т.е. что-то другое вместо `"` для идентификаторов и `'` для строк), реализуйте методы для `sql_escape_string()` и `sql_escape_ident()`.

Сейчас все основные глаголы (`summarise()`, `filter()`, `arrange()`, `mutate()` и т.д.) должны работать, но это тяжело проверить без данных.

### copy_to()

Далее реализуйте методы, что заработала мощь функции `copy_to()`. После того, как вы реализовали эти методы, вы сможете копировать наборы данных из R в вашу базу данный, что сделает проверку гораздо проще.

* `db_data_type()`

* `sql_begin()`, `sql_commit()`, `sql_rollback()`

* `sql_create_table()`, `sql_insert_into()`, `sql_drop_table()`

* `sql_create_index()`, `sql_analyze()`

Если база данных не поддерживает функцию, просто верните `TRUE`, ничего не делая. Если вы считаете, что эти методы очень плохо сооветствуют вашему бекенду, для вас может оказаться проще обеспечить непосредственно метод `copy_to()`.

Сейчас вы должны быть способны скопировать набор данных nycflights13 в вашу базы данных:

```{r, eval=FALSE}
copy_nycflights13(src_mssql(...))
copy_lahman(src_mssql(...))
```

Не продолжайте, пока это не заработает, и вы не убедитесь, что основные глаголы для одной таблицы работают.

## Метаданные запроса

Если ваша база данных обеспечивает хороший способ доступа к метаданным запросов, реализуйте `db_query_fields()` и `db_query_rows()`, которые возвращают имена полей и количество строк для данного запроса.

## Compute, collect и collapse

Далее проверьте, что функции `collapse()`, `compute()` и `collect()` работают.

* Если `collapse()` не работает, ваша база данных использует нестандартный способ создания подзапросов. Добавьте метод для `sql_subquery()`.

* Если `compute()` не работает, ваша база данных использует нестандартный способ сохранения запросов во временных таблицах. Добавьте метод для `db_save_query()`.

## Глаголы для нескольких таблиц

Далее проверьте глаголы для нескольких таблиц:

* `left_join()`, `inner_join()`: работают за счёт `sql_join()`

* `semi_join()`, `anti_join()`: работают за счёт `sql_semi_join()`

* `union()`, `intersect()`, `setdiff()`: работают за счёт `sql_set_op()`

## Трансляция sql

Чтобы закончить, вы можете добавить пользовательскую трансляцию R -> SQL с помощью метода для `src_translate_env()`. Эта функция должна возвращать объект, созданный `sql_variant()`. См. существующие методы для примера.