---
title: "Tidy data"
output: html_document
date: '2015-09-09'
---

### Перевод
### https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html

```{r dir, echo=FALSE, warning=FALSE, message=FALSE}
setwd("D:/GITHUB/dplyr_doc_ru/tidy_data/")
library(tidyr)
library(dplyr)
```

(Это неформальная и более богатая примерами кода версия [публикации](http://vita.had.co.nz/papers/tidy-data.html). Больше подробностей вы можете найти в ней.)

## Придание данным аккуратного вида

Часто говорят, что 80% анализа данных составляет очистка и подготовка данных. И это не просто первый этап, напротив, очистка данных должна повторяться много раз в процессе анализа по мере выявления новых проблем или сбора новых данных. Чтобы помочь справиться с этой задачей, в данной статье рассматривается маленький, но важный аспект очистки данных, который я называю **приданием аккуратного вида** ("tidy" далее перевожу как "аккуратные" - прим. пер.): структурирование наборов данных для облегчения анализа.

Принципы аккуратных данных обеспечивают стандартный способ организации значений в наборе данных. Стандарт делает очистку исходных данных прощу, поскольку вам не нужно каждый раз начинать с нуля и изобретать велосипед. Стандарт аккурантных данных был разработан, чтобы облегчить первичный разведочный анализ данных и упростить разработку средств для анализа данных, которые хорошо работают в сочетании друг с другом. Имеющиеся инструменты часто требуют перевода [из одного формата в другой]. Вам приходится тратить время на переформатирование вывода одного из них, чтобы затем подать на вход другого. Аккуратные наборы данных и соответствующие инструменты работают плечом к плечу, чтобы сделать анализ данных проще, позволяя вам сконцентрироваться на интересной проблеме в своей предметной области, а не на малоинтересной логистике данных.


## Определение аккуратных данных

*«Все счастливые семьи похожи друг на друга, каждая несчастливая семья несчастлива по-своему.» (Л. Толстой)*

Подобно семьям, все аккуратные наборы данных похожи друг на друга, но каждый беспорядочный набор данных беспорядочен по-своему. Аккуратные наборы данных предоставляют стандартный способ связи структуры набора данных (его физической компоновки) с семантикой (его значением). В этом разделе я приведу некий стандартный словарь для описания структуры и семантики набора данных, а затем использую эти термины для определения понятия аккуратных данных.


### Структура данных

Большинство статистических наборов данных являются таблицами, состоящими из **строк** и **столбцов**. Столбцы имеют метки почти всегда, строки - иногда. Следующий код представляет некоторые данные о воображаемом эксперименте в формате, который обычно можно наблюдать в реальных условиях. Таблица содержит два столбца и три строки; и строки, и столцы имеют метки (первый столбец посчитан как метки строк - прим. пер.).

```{r preg.csv, eval = FALSE}
preg <- read.csv("preg.csv", stringsAsFactors = FALSE)
preg
#>           name treatmenta treatmentb
#> 1   John Smith         NA         18
#> 2     Jane Doe          4          1
#> 3 Mary Johnson          6          7
```

Существует много способов структурирования тех же данных. Следующая таблица показывает те же данные, что и предыдущая, но строки и столбцы были транспонированы.

```{r preg2.csv, eval = FALSE}
read.csv("preg2.csv", stringsAsFactors = FALSE)
#>   treatment John.Smith Jane.Doe Mary.Johnson
#> 1         a         NA        4            6
#> 2         b         18        1            7
```

Данные те же, но их формат отличается. Наш словарь, состоящий из строк и столбцов, просто недостаточно богат для описания того, почему эти две таблицы представляют одни и те же данные. В дополнение к внешнему виду, мы также нуждаемся в способе описания лежащей в основе семантики, иными словами, значения данных, отображенных в таблице.


### Семантика данных

Набор данных является совокупностью **значений**, обычно представленных числами (количественные данные) или строками (качественные/категориальные данные). Значения организованы в двух направлениях. Каждое значение принадлежит **переменной** и **наблюдению**. Переменная содержит все значения, которые измеряют один и тот же атрибут (такой как высота, температура, продолжительность) всех объектов. Наблюдение содержит все значения атрибутов, измеренные для одного и того же объекта (такого как человек, день или раса).

Аккуратная версия данных о беременности выглядит следующим образом (немного позже вы узнаете, как работают эти функции):

```{r tudy_preg, eval = FALSE}
library(tidyr)
library(dplyr)
preg2 <- preg %>% 
  gather(treatment, n, treatmenta:treatmentb) %>%
  mutate(treatment = gsub("treatment", "", treatment)) %>%
  arrange(name, treatment)
preg2
#>           name treatment  n
#> 1     Jane Doe         a  4
#> 2     Jane Doe         b  1
#> 3   John Smith         a NA
#> 4   John Smith         b 18
#> 5 Mary Johnson         a  6
#> 6 Mary Johnson         b  7
```

Это делает значения, переменные и наблюдения более понятными. Набор данных содержит 18 значений, представляющий три переменные и шесть наблюдений. Переменные:

1. `name`, с тремя возможными значениями (John, Mary и Jane).

2. `treatment`, с двумя возможными значениями (a и b).

3. `n`, с пятью или шестью значениями в зависимоти от того, как учитывать пропущенные значения (1, 4, 6, 7, 18, NA).

Дизайн эксперимента дает нам больше информации о структуре наблюдений. В этом эксперименте измерялась каждая комбимация имени и лечения (полный перекрестный дизайн). Дизайн эксперимента также определяет, можно ли безболезненно удалять пропущенныезначения. В данном эксперименте пропущенные значения представляют наблюдения, которые должны были быть сделаны, но фактически выполнены не были, поэтому важно сохранить их. Могут быть удалены структурные пропущенные значения, представляющие измерения, которые не могли быть выполнены (например, количество беременных мужчин).

Для конкретного набора данных обычно легко понять, что из себя представляют наблюдения и перменные, но удивительно сложно дать точные опредения переменным и наблюдениям как таковым.
Например, если столбцами в наборе данных о беременности были бы `height` и `weight`, мы с удовольствием назвали бы их переменными. Если бы столбцами были `height` и `width`, это были бы не столь очевидно, так как мы можем думать о высоте и ширине как о значениях переменной `dimension`. Если бы столбцами были `home phone` и `work phone`, мы могли бы считать их двумя переменными, но в контексте выявление случаев мошенничества нам могли бы понадобиться переменные `phone number` и `number type`, поскольку использование одного телефонного номера многими людьми может свидетельствовать о мошенничестве. Общее эмпирическое правило заключается в том, что проще описать функциональную взаимосвязь между переменными (наример, `z` является линейной комбинацией `x` и `y`, `density` является отношением `weight` к `volume`), чем между строками/наблюдениями, и проще выполнять сравнения между группами наблюдений (например, сравнить среднее группы a со средним группы b), чем между группами переменных.

В отдельном анализе может быть несколько уровней наблюдений. Например, в испытании нового лекарства от аллергии мы можем иметь наблюдений трех типов: демографические данные, собранные для каждого человека (`age`, `sex`, `race`); данные, собранные для каждого человека за каждый день (`number of sneezes`, `redness of eyes`); метеорологические данные, собранные за каждый день (`temperature`, `pollen count`).

Переменные могут изменяться в ходе анализа. Часто переменные в исходных данных слишком детализированные, что может увеличивать сложность моделирования при незначительном улучшении объясняющей способности. Например, при проведении многих опросов задают несколько вариантов одного и того же вопроса для получения лучшей характеристики лежащего в основе изучаемого признака. На ранних стадиях анализа переменные соответствуют вопросам. На поздних стадиях вы концентрируетесь на признаках, вычисленных путем усреднения нескольких вопросов. Это значительно упрощает анализ, так как вам не нужна иерархическая модель, и вы часто можете обрабатывать данные как непрерывные, а не как дискретные.


### Аккуратные данные

Аккуратные данные являются стандартным способом отображения содержания набора данных в его структуре. Набор данных является беспорядочным или аккуратным в зависимости от того, как строки, стролбцы и таблицы сопоставляются с наблюдениями, переменными и типами. В аккуратных данных:

1. Каждая переменная формирует столбец.

2. Каждое наблюдение формирует строку.

3. Каждый тип единиц наблюдения формирует таблицу.

Это третья нормальная форма Кодда, но с ограничениями в контексте статистического языка; в центре внимаения находится отдельный набор данных вместо многих связанных между собой наборов, как это обычно имеет место в реляционных базах данных. **Беспорядочными данными** являются любые другие компоновки данных. Аккуратные данные делает извлечение нужных переменных более простым для аналитика или для компьютера, поскольку обеспечивается стандартный способ структурирования набора данных. Сравните разные версии данных о беременности: в беспорядочной версии вы должны использовать разные способы для извлечения разных переменных. Это замедляет анализ и провоцирует ошибки. Если вы посчитаете, как много операций анализа данных включают все значения переменной (каждая агрегирующая функция), то увидите, как важно извлекать эти значения простым стандартным способом. Аккуратные данные особенно хорошо подходят для векторизированных языков программирования, таких как R, потому что такая структура гарантирует, что значения разных переменных для одного и того же наблюдения всегда соответствуют друг другу.

Несмотря на то, что порядок переменных и наблюдений не влияет на анализ, правильное упорядочивание облегчает просмотр исходных значений. Один из способов организации переменных - по их роли в анализе: являются ли значения фиксированными в соответствии с дизайном сбора данных, или же они измеряются в ходе эксперимента? Фиксированные переменные описывают дизайн эксперимента и известны заранее. Специалисты в области компьютерных наук часто называют фиксированные переменные размерностями, а статистики обычно обозначают из с подстрочными индексами по случайным переменным. Измеряемые переменные - это то, что мы на самом деле измеряем в ходе исследования. Фиксированные переменные должны идти первыми, после них - измеряемые переменные, упорядоченные так, что связанные переменные были смежными. Строки затем могут быть упорядочены по первой переменной, а затем по следующим (фиксированным) переменным. Данное соглашение принято для всех таблиц, приведенных в этой публикации.


## Придание аккуратного вида беспорядочным данным

Реальные набора данных могут нарушать (и часто нарушают) три принципы аккуратных данных практически всеми мыслимыми способами. И хотя вы иногда получаете набор данных, с которым можете немедленно начать анализ, это скорее исключение, чем правило. Этот раздел описывает пять наиболее распространенных проблем беспорядочных наборов данных, а также способы их устранения:

* Заголовки столбцов являются значениями, а не именами переменных

* Несколько переменных хранятся в одном столбце.

* Переменные хранятся и в строках, и в столбцах.

* Несколько типов единиц наблюденияхранятся в одной таблице.

* Отдельная единица наблюдения хранятся в нескольких таблицах.

Удивительно, но большинство беспорядочных наборов данных, включая их виды, не описанные в явном виде выше, могут быть приведены к аккуратному виду с помощью небольшого набора инструментов: сбора, разделения и распределения. Следующие разделы иллюстрируют каждую из проблем реальных наборов данных, с которыми я сталкивался, и показывают, как можно привести их в порядок.


### Заголовки столбцов являются значениями, а не именами переменных

Распространенным типом беспорядочных данных являются табличные данные, подготовленные для презентаций, в которых переменные образуют как строки, так и столбцы, и заголовки столбцов являются значениями, а не именами переменных. Хотя я называю такую компоновку беспорядочной, в некоторых случаях она может быть исключительно полезной. Она обеспечивает эффективное хранение для полных перекрестных дизайнов, и это может приводить к чрезвычайно эффективным вычислениям, если требуемые операции могут быть выражены как операции над матрицами.

Следующий код демонстрирует поднабор из типичного набора данных в такой форме. Этот набор данных исследует взаимосвязь между доходом и религией в США. Источником является [отчет](http://www.pewforum.org/religious-landscape-study/), созданный Pew Research Center, американским аналитическим центром, который сибирает данные, касающиеся различных тем - от религии до интернета, а также создает много отчетов с наборами данных в таком формате.

```{r pew.csv, eval = FALSE}
pew <- tbl_df(read.csv("pew.csv", stringsAsFactors = FALSE, check.names = FALSE))
pew
#> Source: local data frame [18 x 11]
#> 
#>                   religion <$10k $10-20k $20-30k $30-40k $40-50k $50-75k
#>                      (chr) (int)   (int)   (int)   (int)   (int)   (int)
#> 1                 Agnostic    27      34      60      81      76     137
#> 2                  Atheist    12      27      37      52      35      70
#> 3                 Buddhist    27      21      30      34      33      58
#> 4                 Catholic   418     617     732     670     638    1116
#> 5       Don’t know/refused    15      14      15      11      10      35
#> 6         Evangelical Prot   575     869    1064     982     881    1486
#> 7                    Hindu     1       9       7       9      11      34
#> 8  Historically Black Prot   228     244     236     238     197     223
#> 9        Jehovah's Witness    20      27      24      24      21      30
#> 10                  Jewish    19      19      25      25      30      95
#> ..                     ...   ...     ...     ...     ...     ...     ...
#> Variables not shown: $75-100k (int), $100-150k (int), >150k (int), Don't
#>   know/refused (int)
```

Этот набор данных содержит три переменные: `religion`, `income` и `frequency`. Чтобы сделать данные аккуратными, мы должны **собрать** столбцы, не являющиеся переменными, в пары ключ-значение, поместив их в два столбца. Это действие часто описывают как перевод широкого набора данных в длинную (или высокую) форму, но я буду избегать этих терминов из-за их неточности.

При сборке переменных мы должны задать имена создаваемых столбцов с ключами и значениями. Первым аргументом является имя столбца с ключами, т.е. имя переменной, определяемой значениями из заголовков [исходных] столбцов. В данном случае, это `income`. Второй аргумент - это имя столбца со значениями, `frequency`. Третий аргумент определяет столбцы для сборки, в данном случае - все столбцы, кроме `religion`.

```{r gather, eval = FALSE}
pew %>%
  gather(income, frequency, -religion)
#> Source: local data frame [180 x 3]
#> 
#>                   religion income frequency
#>                      (chr) (fctr)     (int)
#> 1                 Agnostic  <$10k        27
#> 2                  Atheist  <$10k        12
#> 3                 Buddhist  <$10k        27
#> 4                 Catholic  <$10k       418
#> 5       Don’t know/refused  <$10k        15
#> 6         Evangelical Prot  <$10k       575
#> 7                    Hindu  <$10k         1
#> 8  Historically Black Prot  <$10k       228
#> 9        Jehovah's Witness  <$10k        20
#> 10                  Jewish  <$10k        19
#> ..                     ...    ...       ...
```

Эта форма является аккуратной, поскольку каждый столбец представляет переменную, а каждая строка - это наблюдение, в данном случае - демографическая единица, соответствующая комбинации  `religion` и `income`.

Этот формат также испоользуется для представления наблюдений, равномерно распределенных по времени. Например, набор данных `billboard`, показанный ниже, содержит даты когда песня впервые попала в Топ 100.  Он содержит переменные `artist`, `track`, `date.entered`, `rank` и `week`. Места, занимаемые в течение каждой недели после попадания в Топ 100, преставлены в 75 столбцах - от `wk1` до `wk75`. Эта форма хранения не является аккуратной, но она удобна для ввода данных: уменьшается дублирование, поскольку иначе для каждой песни за каждую неделю потребуется отдельная строка, и метаданные песни, такие как название и исполнитель, будут дублироваться. Этот вопрос будет обсуждаться подробнее в разделе про хранение нескольких типов единиц наблюдения.

```{r billboars, eval = FALSE}
billboard <- tbl_df(read.csv("billboard.csv", stringsAsFactors = FALSE))
billboard
#> Source: local data frame [317 x 81]
#> 
#>     year         artist                   track  time date.entered   wk1
#>    (int)          (chr)                   (chr) (chr)        (chr) (int)
#> 1   2000          2 Pac Baby Don't Cry (Keep...  4:22   2000-02-26    87
#> 2   2000        2Ge+her The Hardest Part Of ...  3:15   2000-09-02    91
#> 3   2000   3 Doors Down              Kryptonite  3:53   2000-04-08    81
#> 4   2000   3 Doors Down                   Loser  4:24   2000-10-21    76
#> 5   2000       504 Boyz           Wobble Wobble  3:35   2000-04-15    57
#> 6   2000           98^0 Give Me Just One Nig...  3:24   2000-08-19    51
#> 7   2000        A*Teens           Dancing Queen  3:44   2000-07-08    97
#> 8   2000        Aaliyah           I Don't Wanna  4:15   2000-01-29    84
#> 9   2000        Aaliyah               Try Again  4:03   2000-03-18    59
#> 10  2000 Adams, Yolanda           Open My Heart  5:30   2000-08-26    76
#> ..   ...            ...                     ...   ...          ...   ...
#> Variables not shown: wk2 (int), wk3 (int), wk4 (int), wk5 (int), wk6
#>   (int), wk7 (int), wk8 (int), wk9 (int), wk10 (int), wk11 (int), wk12
#>   (int), wk13 (int), wk14 (int), wk15 (int), wk16 (int), wk17 (int), wk18
#>   (int), wk19 (int), wk20 (int), wk21 (int), wk22 (int), wk23 (int), wk24
#>   (int), wk25 (int), wk26 (int), wk27 (int), wk28 (int), wk29 (int), wk30
#>   (int), wk31 (int), wk32 (int), wk33 (int), wk34 (int), wk35 (int), wk36
#>   (int), wk37 (int), wk38 (int), wk39 (int), wk40 (int), wk41 (int), wk42
#>   (int), wk43 (int), wk44 (int), wk45 (int), wk46 (int), wk47 (int), wk48
#>   (int), wk49 (int), wk50 (int), wk51 (int), wk52 (int), wk53 (int), wk54
#>   (int), wk55 (int), wk56 (int), wk57 (int), wk58 (int), wk59 (int), wk60
#>   (int), wk61 (int), wk62 (int), wk63 (int), wk64 (int), wk65 (int), wk66
#>   (lgl), wk67 (lgl), wk68 (lgl), wk69 (lgl), wk70 (lgl), wk71 (lgl), wk72
#>   (lgl), wk73 (lgl), wk74 (lgl), wk75 (lgl), wk76 (lgl)
```

Чтобы сделать этот набор данных аккуратным, мы прежде всего должны собрать вместе столбцы `wk`. Имена столбцов зададут переменную `week`, а значения - переменную `rank`:

```{r billboard2, eval = FALSE}
billboard2 <- billboard %>% 
  gather(week, rank, wk1:wk76, na.rm = TRUE)
billboard2
#> Source: local data frame [5,307 x 7]
#> 
#>     year         artist                   track  time date.entered   week
#>    (int)          (chr)                   (chr) (chr)        (chr) (fctr)
#> 1   2000          2 Pac Baby Don't Cry (Keep...  4:22   2000-02-26    wk1
#> 2   2000        2Ge+her The Hardest Part Of ...  3:15   2000-09-02    wk1
#> 3   2000   3 Doors Down              Kryptonite  3:53   2000-04-08    wk1
#> 4   2000   3 Doors Down                   Loser  4:24   2000-10-21    wk1
#> 5   2000       504 Boyz           Wobble Wobble  3:35   2000-04-15    wk1
#> 6   2000           98^0 Give Me Just One Nig...  3:24   2000-08-19    wk1
#> 7   2000        A*Teens           Dancing Queen  3:44   2000-07-08    wk1
#> 8   2000        Aaliyah           I Don't Wanna  4:15   2000-01-29    wk1
#> 9   2000        Aaliyah               Try Again  4:03   2000-03-18    wk1
#> 10  2000 Adams, Yolanda           Open My Heart  5:30   2000-08-26    wk1
#> ..   ...            ...                     ...   ...          ...    ...
#> Variables not shown: rank (int)
```

Здесь мы использовали `na.rm`, чтобы удалить любые пропущенные значения в объединенном столбце. В этих данных пропущенные значения представляют недели, когда песня не была в чартах, поэтому от них можно безболезненно избавиться.

В данном случае также целесообразно выполнить небольшую очистку, превратив переменную `week` в числовую и вычислив дату, соответствующую каждой неделе в чартах:

```{r billboard3, eval = FALSE}
billboard3 <- billboard2 %>%
  mutate(
    week = extract_numeric(week),
    date = as.Date(date.entered) + 7 * (week - 1)) %>%
  select(-date.entered)
billboard3
#> Source: local data frame [5,307 x 7]
#> 
#>     year         artist                   track  time  week  rank
#>    (int)          (chr)                   (chr) (chr) (dbl) (int)
#> 1   2000          2 Pac Baby Don't Cry (Keep...  4:22     1    87
#> 2   2000        2Ge+her The Hardest Part Of ...  3:15     1    91
#> 3   2000   3 Doors Down              Kryptonite  3:53     1    81
#> 4   2000   3 Doors Down                   Loser  4:24     1    76
#> 5   2000       504 Boyz           Wobble Wobble  3:35     1    57
#> 6   2000           98^0 Give Me Just One Nig...  3:24     1    51
#> 7   2000        A*Teens           Dancing Queen  3:44     1    97
#> 8   2000        Aaliyah           I Don't Wanna  4:15     1    84
#> 9   2000        Aaliyah               Try Again  4:03     1    59
#> 10  2000 Adams, Yolanda           Open My Heart  5:30     1    76
#> ..   ...            ...                     ...   ...   ...   ...
#> Variables not shown: date (date)
```

Наконец, никогда не лишим будет отсортировать данные. Мы можем сделать это по исполнителю, песне и неделе:

```{r billboard_arrange1, eval = FALSE}
billboard3 %>% arrange(artist, track, week)
#> Source: local data frame [5,307 x 7]
#> 
#>     year  artist                   track  time  week  rank       date
#>    (int)   (chr)                   (chr) (chr) (dbl) (int)     (date)
#> 1   2000   2 Pac Baby Don't Cry (Keep...  4:22     1    87 2000-02-26
#> 2   2000   2 Pac Baby Don't Cry (Keep...  4:22     2    82 2000-03-04
#> 3   2000   2 Pac Baby Don't Cry (Keep...  4:22     3    72 2000-03-11
#> 4   2000   2 Pac Baby Don't Cry (Keep...  4:22     4    77 2000-03-18
#> 5   2000   2 Pac Baby Don't Cry (Keep...  4:22     5    87 2000-03-25
#> 6   2000   2 Pac Baby Don't Cry (Keep...  4:22     6    94 2000-04-01
#> 7   2000   2 Pac Baby Don't Cry (Keep...  4:22     7    99 2000-04-08
#> 8   2000 2Ge+her The Hardest Part Of ...  3:15     1    91 2000-09-02
#> 9   2000 2Ge+her The Hardest Part Of ...  3:15     2    87 2000-09-09
#> 10  2000 2Ge+her The Hardest Part Of ...  3:15     3    92 2000-09-16
#> ..   ...     ...                     ...   ...   ...   ...        ...
```

Или по дате и месту в чарте:

```{r billboard_arrange2, eval = FALSE}
billboard3 %>% arrange(date, rank)
#> Source: local data frame [5,307 x 7]
#> 
#>     year   artist  track  time  week  rank       date
#>    (int)    (chr)  (chr) (chr) (dbl) (int)     (date)
#> 1   2000 Lonestar Amazed  4:25     1    81 1999-06-05
#> 2   2000 Lonestar Amazed  4:25     2    54 1999-06-12
#> 3   2000 Lonestar Amazed  4:25     3    44 1999-06-19
#> 4   2000 Lonestar Amazed  4:25     4    39 1999-06-26
#> 5   2000 Lonestar Amazed  4:25     5    38 1999-07-03
#> 6   2000 Lonestar Amazed  4:25     6    33 1999-07-10
#> 7   2000 Lonestar Amazed  4:25     7    29 1999-07-17
#> 8   2000    Amber Sexual  4:38     1    99 1999-07-17
#> 9   2000 Lonestar Amazed  4:25     8    29 1999-07-24
#> 10  2000    Amber Sexual  4:38     2    99 1999-07-24
#> ..   ...      ...    ...   ...   ...   ...        ...
```


### Несколько переменных хранятся в одном столбце

Бывает, что после сборки столбцов столбец со значениями ключей является комбинацией нескольких переменных, лежащих в его основе.

